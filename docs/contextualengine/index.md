---
title: 
layout: default
---

# Contextual Engine 

The contextual engine is the center of ContextHub, adding dynamic capabilities to events generated by your apps through context rules. The contextual engine aims to solve the problem of allowing developers to change how their app behaves based on events generated by a device to create a more seamless experience for end users. Through events, feeds, and context rules, you'll be able to build more quickly modern, contextually-aware applications your users will enjoy.


<a name="beacon"></a>
<a data-magellan-destination="beacon"></a>

## Beacon

Beacons are Bluetooth 4.0 Low Energy devices that allow devices to detect proximity to objects within 50 meters. This gives you the ability to give context-sensitive information to your users in areas where GPS, WiFi, and cellular towers cannot pinpoint a user's exact location, such as deep inside buildings or underground. Here's how to use the `beacon` object to interact with beacons in a context rule:
<br />
<br />

<a name="beacon-creating"></a>
<a data-magellan-destination="beacon-creating"></a>

### Creating

Creating a beacon contextual element in ContextHub is simple. Every beacon has a UUID (32 digit hexadecimal character, a major value (ranging from 1-65535), and a minor value (also ranging from 1-65535). UUIDs you use should be unique so beacons from other user's do not interfere with your app. A combination of these three values should be unique for every beacon you have.

{% gist CHLibrarian/9c62b626473a434dfc5b %}
<br />

<a name="beacon-response"></a>
<a data-magellan-destination="beacon-response"></a>

### Response

Once a beacon is created, a hash response is returned with the following keys: 

- `id` - The unique id identifying the beacon
- `name` - The name of the beacon 
- `uuid` - A 32-hexadecimal character string displayed in five groups separated by hyphens, in standardized UUID/GUID format (`8-4-4-4-12`)
- `major` - A 16-bit value from 1-65535
- `minor` - A 16-bit value from 1-65535 
- `tags` - An array of strings representing the tags for the beacon
- `tag_string` - An auto-generated read-only string representation of the tags used by Keen.io for analysis  

Here's the structure of a beacon that was created above:

{% gist CHLibrarian/13d02a106b74289d1dc3 %}
<br />

<a name="beacon-retrievingbytag"></a>
<a data-magellan-destination="beacon-retrievingbytag"></a>

### Retrieving by Tag

Retrieve a group of beacons from ContextHub by passing a tag to `beacon`. Adding more tags seperated by commas to the same function call filters only beacons that have *all* tags on the same beacon.

{% gist CHLibrarian/1bc45aa1d2b7008fa6f2 %}
<br />

<a name="beacon-retrievingbyid"></a>
<a data-magellan-destination="beacon-retrievingbyid"></a>

### Retrieving by ID

Retrieve a specific beacon from ContextHub by passing a beacon ID present either in the ContextHub developer portal or given to you as a hash response at the key `id` in a context rule.

{% gist CHLibrarian/494e611bd57f6d0d8863 %}
<br />

<a name="beacon-updating"></a>
<a data-magellan-destination="beacon-updating"></a>

### Updating

Updating a beacon is similar to creating one. ContextHub first updates the beacon on the server, then triggers pushes to devices interested in beacons with that specific tag.

{% gist CHLibrarian/84a08b4677d54937dc81 %}
<br />

<a name="beacon-deleting"></a>
<a data-magellan-destination="beacon-deleting"></a>

### Deleting

Deleting a beacon only requires passing the id to the `beacon` object. The beacon is deleted from ContextHub, then triggers pushes to devices interested in beacon deletions with those specific tags.

{% gist CHLibrarian/6bb47bccf63793f6864c %}
<br />

<a name="geofence"></a>
<a data-magellan-destination="geofence"></a>

## Geofence

Geofences are pre-defined areas of interest that allow your application to be notified when a device has entered or exited that region. Here's how to use the `geofence` object to interact with geofences:
<br />
<br />

<a name="geofence-creating"></a>
<a data-magellan-destination="geofence-creating"></a>

### Creating

Creating a geofence contextual element in ContextHub is simple. Every geofence is defined by a latitude and longitude indicating their center and a radius in meters to create the perimeter.

{% gist CHLibrarian/10308ee7887765d11b29 %}
<br />

<a name="geofence-response"></a>
<a data-magellan-destination="geofence-response"></a>

### Response

Once a geofence is created, a hash response is returned with the following keys: 

- `id` - The unique id identifying the geofence
- `name` - The name of the geofence 
- `latitude` - A float between -90 and 90 representiting the latitude coordinate
- `longitude` - A float between -180 and 180 representing the longitude coordinate
- `radius` - An integer representing the radius
- `tags` - An array of strings representing the tags for the geofence
- `tag_string` - An auto-generated read-only string representation of the tags used by Keen.io for analysis  

Here's the structure of a geofence that was created above:

{% gist CHLibrarian/27c84da6c401fd4e312c %}
<br />

<a name="geofence-retrievingbytag"></a>
<a data-magellan-destination="geofence-retrievingbytag"></a>

### Retrieving by Tag

Retrieve a group of geofences from ContextHub by passing a tag to `geofence`. Adding more tags seperated by commas to the same function call filters only beacons that have *all* tags on the same geofence.

{% gist CHLibrarian/4ed014db0c57e58fd3a2 %}
<br />

<a name="geofence-retrievingbyid"></a>
<a data-magellan-destination="geofence-retrievingbyid"></a>

### Retrieving by ID

Retrieve a specific geofence from ContextHub by passing a geofence ID present either in the ContextHub developer portal or given to you as a hash response at the key `id` in a context rule.

{% gist CHLibrarian/268b1e9bd2b3e1b157e2 %}
<br />

<a name="geofence-updating"></a>
<a data-magellan-destination="geofence-updating"></a>

### Updating

Updating a geofence is similar to creating one. ContextHub first updates the geofence on the server, then triggers pushes to devices interested in geofences with that specific tag.

{% gist CHLibrarian/54183962334352202b4c %}
<br />

<a name="geofence-deleting"></a>
<a data-magellan-destination="geofence-deleting"></a>

### Deleting

Deleting a geofence only requires passing the id to the `geofence` object. The geofence is deleted from ContextHub, then triggers pushes to devices interested in geofence deletions with those specific tags.

{% gist CHLibrarian/fd892e5fa5075f97f19f %}
<br />

<a name="http"></a>
<a data-magellan-destination="http"></a>

## HTTP

The HTTP object allows you to fire webhooks to other services in a context rule. This allows you to communicate with external servers inside ContextHub to provide two-way communication with devices that have generated events such as IoT-like devices like the Raspberry Pi, Arduino, or Electric Imp. 
<br />

<a name="http-get"></a>
<a data-magellan-destination="http-get"></a>

### GET

The GET method allows you to perform an HTTP GET request to a specific URL. The `parameters` parameter lets you pass in a hash which will be converted to a long string-escaped GET URL (`?message=get%20message%20from%20webhook`)

{% gist CHLibrarian/9a5e0f673a526ee790a2 %}
<br />

<a name="http-post"></a>
<a data-magellan-destination="http-post"></a>

### POST

The POST method allows you to perform HTTP POST request to a sepcific URL. The `body` parameter lets you pass a body with the request, and headers lets you set custom headers with the request.

{% gist CHLibrarian/ae16587c627cf3e8d520 %}
<br />

<a name="push"></a>
<a data-magellan-destination="push"></a>

## Push

The push object allows you to send foreground and background notifications to devices in a context rule. You have the option of sending notifications to devices based on their token, device id, alias, or one of many tags they may have. By allowing for notifications to be sent based on different groups, you can abstract away some of the complexity of sending push messages to devices and focus more on the core logic of your application. Here's how to use the `push` object to send push notifications:
<br />
<br />

<a name="push-sendingforeground"></a>
<a data-magellan-destination="push-sendingforeground"></a>

### Sending (Foreground)

There are four ways to send a push message to devices in the foreground: token, device id, alias, and tags. Each method takes the identifier plus the message to be sent.

{% gist CHLibrarian/f5aab36ce20d86828099 %}
<br />

<a name="push-sendingbackground"></a>
<a data-magellan-destination="push-sendingbackground"></a>

### Sending (Background)

There are four ways to send a push message to devices in the background: token, device id, alias, and tags. Each method takes the identifier, the data to be sent, and an optional sound to be played when a push is received (a push with "" for a sound isn't played at all and becomes a silent notification). For iOS devices, silent notifications do not have guaranteed delivery, and may piggyback a foreground notification if rate-limited.

{% gist CHLibrarian/00bbaea42964509b55b1 %}
<br />

<a name="vault"></a>
<a data-magellan-destination="vault"></a>

## Vault

Vaults are pre-defined areas of interest that allow your application to be notified when a device has entered or exited that region. Here's how to use the `vault` object to interact with vault:
<br />
<br />

<a name="vault-creating"></a>
<a data-magellan-destination="vault-creating"></a>

### Creating

Creating a vault item is simple. Vault items need to be JSON-serializable `NSDictionary` items so they can be saved properly in ContextHub. In general, values stored are numbers, strings, arrays, and dictionaries, which allows for an arbitrary nesting of values. Below is an example of creating a vault item:

{% gist CHLibrarian/a098fd2a92e835982b20 %}
<br />

<a name="vault-response"></a>
<a data-magellan-destination="vault-response"></a>

### Response

Once a vault item is created, a hash response is returned with the following keys: 

- `data` - A hash containing your stored data
- `vault_info` - A hash containing metadata about the vault item
    - `id` - A 32-hexadecimal character string displayed in five groups separated by hyphens, in standardized UUID/GUID format (`8-4-4-4-12`), uniquely identifying a vault item
    - `created_at` - An ISO 8601 timestamp representing when a vault item was created 
    - `updated_at` - An ISO 8601 timestamp representing when a vault item was last updated
    - `tags` - An array of strings representing the tags for the vault item
    - `tag_string` - An auto-generated read-only string representation of the tags used by Keen.io for analysis  

Here's the structure of a vault item that was created above:

{% gist CHLibrarian/f03d82ad1e2e1c4b5d0c %}
<br />

<a name="vault-retrievingbytag"></a>
<a data-magellan-destination="vault-retrievingbytag"></a>

### Retrieving by Tag

Retrieve a group of vault items from ContextHub by passing a tag to `vault`. Adding more tags seperated by commas to the same function call filters only beacons that have *all* tags on the same vault items.

{% gist CHLibrarian/f95de5fabe8af80431ce %}
<br />

<a name="vault-retrievingbyid"></a>
<a data-magellan-destination="vault-retrievingbyid"></a>

### Retrieving by ID

Retrieve a specific vault item from ContextHub by passing a vault ID present either in the ContextHub developer portal or given to you as a hash response at the key `id` in a context rule.

{% gist CHLibrarian/08e7a097a018ae13b8b2 %}
<br />

<a name="vault-retrievingbyvalue"></a>
<a data-magellan-destination="vault-retrievingbyvalue"></a>

### Retrieving by Value

Contains allows you to search inside a vault item for a particular value.

{% gist CHLibrarian/ccd10b6bf887a37037fc %}
<br />

<a name="vault-retrievingbykeypathvalue"></a>
<a data-magellan-destination="vault-retrievingbykeypathvalue"></a>

### Retrieving by Matching KeyPath/Value

KeyPath search allows you to get all items which a matching value for a specific keypath. 

{% gist CHLibrarian/833335fce9bb9e522407 %}
<br />

<a name="vault-updating"></a>
<a data-magellan-destination="vault-updating"></a>

### Updating

Updating a vault item is similar to creating one. ContextHub first updates the vault item on the server, then triggers pushes to devices interested in vault items with those specific tags.

{% gist CHLibrarian/cd7dc04e6624ebbc35e2 %}
<br />

<a name="vault-deleting"></a>
<a data-magellan-destination="vault-deleting"></a>

### Deleting

Deleting a vault items only requires passing the id to the `vault` object. The vault item is deleted from ContextHub, then triggers pushes to devices interested in vault item deletions with those specific tags.

{% gist CHLibrarian/a55f094872efed65ad3b %}
<br />


<a name="events"></a>
<a data-magellan-destination="events"></a>

##EVENTS

Sensors in modern devices generate a lot of data which ContextHub packages today into an event. The event data structure contains keys about the event which you can use in context rules to create advanced processing on the ContextHub server. All events have a very basic structure with 6 important keys: 

- `name` - The name of the event which will determine the context rule(s) to be executed
- `data` - The data from the event specific to the event type (pre-defined events have pre-defined structures, see below for more info)
    - `datetime` - Every pre-defined event will have an ISO 8601 timestamp indicating when the event was triggered by the device.
- `context` - Context represents data about the device which generated the event
    - `device_context` - Basic data about the device: model, type, OS version, and device id
    - `geofence_context` - A list of geofences the device was last in when the event occurred
    - `location_context` - Basic location data about the device when the event occured
    - `ranged_beacons_context` - A list of specific beacons in range of the device when the event occured
- `payload` - Developer-defined custom data sent along with every event generated by the ContextHub SDK.
- `id` - A unique 32-hexadecimal character string displayed in five groups separated by hyphens, in standardized UUID/GUID format (`8-4-4-4-12`)
- `created_at` - An IOS 8601 timestamp created when the event was created on the server.
<br />
<br />

<a name="events-sampleevent"></a>
<a data-magellan-destination="events-sampleevent"></a>

###Sample Event

Here is the structure of a sample event:
{% gist CHLibrarian/18c01d70d2448bfec465 %}
<br />

<a name="events-beaconinout"></a>
<a data-magellan-destination="events-beaconinout"></a>


###Beacon In/Out

The `beacon_in`/`beacon_out` event is generated whenever a device enters or exits a beacon region. A beacon region is defined as a UUID + major/minor values, if provided. If not provided, then several beacons having the same UUID will only trigger a `beacon_in` event once. Inside the `data` key, there is a `beacon` key indicating the beacon region which was just entered/exited and the UUID for the beacon region. Major and minor values will be filled only if the monitored region in ContextHub has them (they are not required). To get events about specific beacons, specifically `state` and `accuracy` values, look at `beacon_changed`.

{% gist CHLibrarian/4124b79edcc0e6969f8d %}
<br />

<a name="events-beaconchanged"></a>
<a data-magellan-destination="events-beaconchanged"></a>

### Beacon Changed

The `beacon_changed` event is generated whenever a device changes proximity of a *specific* beacon. There are three pre-defined states, `immediate_state`, `near_state`, and `far_state` which are approximately 0-6 inches, 6-12 inches, and 12 inches - 50 feet depending on the range and power setting of the particular beacon used. Within the `beacon` key of the `data` key, you will find the specific `major` and `minor` values of the beacon, as well as the `rssi` value giving relative strength. Estimote explains very well [here](https://community.estimote.com/hc/en-us/articles/201029223-RSSI-Range-Zones-and-Distance-Accuracy) RSSI values and how they relate to distance between a device an a beacon. `accuracy` is also another key present which gives the approximate distance from the beacon to the device. Given the number of factors that influence wireless signals in an area, the accuracy value should be used as a general guideline, and not relied on in critical scenarios.

{% gist CHLibrarian/4768b16d3e6a1b95785d %}
<br />

<a name="events-geofenceinout"></a>
<a data-magellan-destination="events-geofenceinout"></a>

###Geofence In/Out

The `geofence_in`/`geofence_out` is generated whenever a device enters or exists a circular geofence region. A geofence region is defined as a geospatial center with latitude and longitude, and radius in meters. Inside the `data` key, there is a `fence` key indicating the geofence region which was just entered/exited along with the latitude, longitude, and radius of the geofence. The `state` key determines whether the event was a `geofence_in` or `geofence_out` event.
{% gist CHLibrarian/9d4439ed9ed94720514f %}
<br />


<a name="events-locationchanged"></a>
<a data-magellan-destination="events-locationchanged"></a>

###Location Changed

The `location_changed` event is generated whenever a device has a significant location change as defined by the platform. For iOS, this is approximately once every 1000 meters, depending on WiFi/cellular tower density and GPS availability. The `data` structure contains keys related to the `latitude`, `longitude`, `speed`, `altitude`, and `course` of the device at the time the event was generated.

{% gist CHLibrarian/33148acb910e8c3c31d2 %}
<br />

<!-- 
###Motion Changed

The `motion_changed` event is generated whenever an iOS device with the M7 chip transitions between various states representing different modes of transportation: `stationary`, `walking`, `running`, and `driving`. The `data` key contains two keys (`current_activity` and `previous_activity`) representing the current and previous activities respectively along with a `start_date` timestamp and `confidence` key representing how confident the M7 is that the state of the activity is accurate.

{% gist CHLibrarian/ea17579eb481ac658a36 %}
<br />
-->


<a name="events-tick"></a>
<a data-magellan-destination="events-tick"></a>

### Tick

The `tick` event is a special event that is automatically executed once every minute in the ContextHub server. Using the JavaScript `Date()` object and checking the time, this allows you the ability to execute commands in ContextHub even with the *absence* of any events on the server. So instead of your server code simply being reactive to devices, it can be a proactive part of your applications.

{% gist CHLibrarian/109cad3805c2650fe9f0 %}
<br />


<a name="events-customevents"></a>
<a data-magellan-destination="events-customevents"></a>

###Custom Events

Custom events are events triggered by the developer that have no predefined data structure. These events are manually triggered by the SDK through a specific method, or by posting an event through a feed for web browsers, servers, JavaScript scripts, and IoT-like devices like the Raspberry Pi or Arduino. All custom events must have a defined `name` key, so they can be processed by the appropriate context rule if it exists and should have the `data` key representing your custom data structure. Custom events generated by non-SDK devices, will not have either the `context` or `payload` unless they are defined by you, the application developer. 

Below is a sample of a data structure of a custom event, taken from the [Awareness](/samples/ios/awareness) context rule sample app.

{% gist CHLibrarian/57a43d174de887c0b778 %}
<br />


<a name="triggers"></a>
<a data-magellan-destination="triggers"></a>

##Triggers

Triggers are specially crafted, application-specific URLs generated by ContextHub that let you trigger your own custom events from any web browser, JavaScript script, Arduino, Raspberry Pi, or other IoT device. Triggers are perfect for integrating new platforms not yet directly supported by our SDKs into your own applications.

<a name="triggers-creating"></a>
<a data-magellan-destination="triggers-creating"></a>


###Creating

Creating a trigger is simple. In the developer portal, select an app, then click on *Settings*, then the *Triggers* tab to see all the triggers for you app. To create a new trigger, click the *New Trigger* button and type in a name of the trigger. A generated trigger looks like this:

`https://app.contexthub.com/api/triggers/:token/:event_name`

- `:token` - random alphanumeric string generated by ContextHub tying the events for the trigger directly to your app
    - Example: `1782914xneuuoy26b6g45swco`
- `:event_name` - name of the event which will match the context rule during rule processing
    - Example: `arduino_event`

So the full URL for a trigger linked to your app that would post the `arduino_event` would be:

`https://app.contexthub.com/api/triggers/1782914xneuuoy26b6g45swco/arduino_event`

<a name="triggers-posting"></a>
<a data-magellan-destination="triggers-posting"></a>

###Posting

To use a trigger, you need to generate an HTTP POST request with the appropriate token and event name, along with posting the JSON body that represents the data for your event. The web request should have the `Content-Type` header set to `application/json` so the body is parsed correctly. A web tool like [Hurl.it](http://www.hurl.it) is a great way to test that your triggers are working correctly and you are passing the correct data to a context rule.



















